import collections
import copy
import operator
from functools import reduce
from itertools import starmap

__all__ = ['ndarray']

def infer_shape(sequence):
    shape = []
    while isinstance(sequence, collections.Sequence):
        shape.append(len(sequence))
        sequence = sequence[0]
    if shape == []:
        return (0,)
    else:
        return tuple(shape)

class simplebuffer(list):
    def __init__(self, size):
        super().__init__([0.0])
        if size > 0:
            super().__imul__(size)

class ndarray:
    def __init__(self, shape, buffer=None):
        '''
        shape is a tuple, describing the array dimensions.
        An array containing 10 elements is created like so:
        >>> ndarray(shape=(10,))
        ndarray([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        A 3x3 matrix is:
        >>> ndarray((3, 3)):
        ndarray([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])
        '''
        if isinstance(buffer, ndarray):
            raise TypeError("Use copy() or deepcopy() from the copy module to copy ndarrays")
        self.shape = shape
        c_type = None
        data_len = 1
        # weights of each index
        self.weights = [1]
        for dim in reversed(shape):
            if dim < 0:
                raise ValueError('shape cannot have negative dimensions')
            data_len *= dim
            self.weights.insert(0, dim * self.weights[-1])
        self.weights = tuple(self.weights[1:])
        if data_len == 0 and len(shape) != 1:
            raise ValueError('shape cannot have 0-width dimnsions, unless it is (0,)')
        self.buffer = simplebuffer(data_len)
        if buffer is not None:
            inferred_shape = infer_shape(buffer)
            if inferred_shape != shape and inferred_shape != (data_len,):
                raise ValueError('Shape mismatch: given {0}, buffer {1}'.format(shape, inferred_shape))
            if inferred_shape == (0,):
                self.buffer = copy(buffer)
            else:
                for i in range(len(shape) - 1):
                    buffer = sum(buffer, [])
                self.buffer[:] = tuple(map(float, buffer))

    def __len__(self):
        return shape[0]

    def __iter__(self):
        return Iterator(self)

    def __reversed__(self):
        return ReverseIterator(self)

    def __contains__(self, item):
        # TODO:
        raise NotImplementedError()

    def __setitem__(self, key, value):
        # TODO:
        raise NotImplementedError()

    def __getitem__(self, key):
        if not isinstance(key, tuple):
            raise NotImplementedError()
        else:
            if not len(key) == len(self.shape):
                raise NotImplementedError()
            index = sum(starmap(operator.mul, zip(self.weights, key)))
            return self.buffer[index]

    def __repr__(self):
        return 'ndarray({0}, {1})'.format(self.shape, self.buffer)

class Iterator:
    def __init__(self, array):
        self.array = array
        self.pos = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.pos >= self.array.shape[0]:
            raise StopIteration
        ret = self.array[self.pos]
        self.pos += 1
        return ret

class ReverseIterator:
    def __init__(self, array):
        self.array = array
        self.pos = array.shape[0] - 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.pos < 0:
            raise StopIteration
        ret = self.array[self.pos]
        self.pos -= 1
        return ret

